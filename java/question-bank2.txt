Difference b/w failfast and failsafe iterators ?

Failfast iterators - these throw ConcurrentModification Exception when one Thread is iterating
over collection object while other thread is structurally modifying COllection(adding, deleting, modifying)
objects on underlying collection, They are call failfast because they immediately throw exception when
they encounter failure.

FailSafe - doesnt throw any exception is modified structurally because they work on clone of the 
collection instead of the original Collection.

---------------------------------------------------

What do you understand by blocking Queue ?

The java BlockingQueue interface, java.util.concurrentBlockingQueue represents a queue which is thread safe
to put elements into and take elements out from, in other words multiple threads can be inserting and
taking elements concurrently from a java BlockingQueue, without any concurrency issue arising.

basically, its thread safe queue.

----------------------------------------------------

Difference b/w synchronized collection and concurrent collection ?

Both Synchronized and Concurrent Collection classes provide thread safety.
the difference between them comes in peformance, scalability and how they achieve thread safety
Synchronized collections like synchronized HashMap are much slower than their concurrent counterparts eg.
ConcurrentHashMap, Main reason for this slowness is Locking.

lets say our collection is  divided into segments s1, s2, s3, s4, and a thread tries write operation on s1
in case of synchronized all segments are locked by this thread and other threads have to wait.
While in concurrent collection only segment1 is locked for read and write while all other 3 segments are open 
for other threads. It is called lock striping.

----------------------------------------------------

Internal working of HashMap

HashMap in java works on hashing principle where a hash function are used to link key and value in HashMap,
Objects(Map.Entry -> contains both key and value object) are stored by calling put(key, value)method of
HashMap and retrieved by calling get(key) method.

When we call put method, hashCode() method of the key object is called which calculates an index of the 
bucket location where we can store the value object.

To retrieve, you call the get() method and again pass the key object, which lands you up at same index or 
bucket and you retrieve the value object.

Diagram - https://www.youtube.com/watch?v=KfoNYoVUBJI&t=1383s

In case of collision(multiple keys give same hashcode which gives same bucket number), a new node will be 
inserted after current node at the same bucket location in the form of linked list.

in case of get(key) operation it will get a bucket location (by getting hashCode of key)
 and then traverse the linked list present there starting from the first node and compare
 all keys of all nodes using equals() method until if finds it and returns the value.

 ----------------------------------------------------

Is Java pass by value or pass by reference ?

pass by value : from calling function we pass a copy of the variable and not the address so any change
    done to that variable in the other function will not reflect in the calling function variable.

pass by reference : we pass the original reference of the variable so any change done to that variable
    in that reference will also reflect in the calling function variable.

public class Animal{
    int eyes;
    protected String animalName ="mouse";
    public static void main(){
        Animal animalobj = new Animal();
        animalobj.eyes=2;
        int a = 3;
        changePrimitives(a);
        Syso("value of a is " +a); // 3, will retain original as while passing java changes its reference.
        changeObjectReference(animalobj);
        Syso(animalobj.eyes); // 12, it changed because we are passing a reference/memory address.
    }
    public static void changePrimitives(int aCopy) {
        aCopy = 13;
    }
    public static void changeObjectReference(Animal animalobjCopy){
        animalobjCopy = 12;
    }
}

By default if we pass the object, you are actually passing the reference hence change is reflected.
But for primitive types we can see that its not changed(it passes copy of variable inside different reference),
Hence Java is pass by value. 

 ----------------------------------------------------

 Why do we need Comparator and Comparable Interfaces in JAVA ?
  
  int[] arr = new int[]{3, 1, 5, 2};
  Arrays.sort(arr); // will sort the array

but for custom java objects like Employee, this is not true.
    Employee[] emparr = new Employee[4]; // then add some employees like {{1,"shiv"},{2,"abhi"}...}.
    This will throw an exception : cant cast Employee to java.lang.Comparable;

Hence we need Comparable and Comparator interface for custom objects in java.

1. To implement Comparable we need to implement Comparable interface in the Employee class.
2. also we need to override compareTo() method of Comparable interface.

public class Employee implements Comparable<T> {
    ...
    @Override 
    public int compareTo(Employee o) { 
        return this.id - o.id; // it can return 0, -ve, +ve
    }
}
Now this class cast exception will not come.

Now with comparable we can only do sorting based on one id, but if we want to use both id first(default) then
by name then we can use Comparator. ??

public class Employee implements Comparable<T> {
    ...
    @Override 
    public int compareTo(Employee o) { 
        return this.id - o.id; // it can return 0, -ve, +ve
    }
    
    public static Comparator<Employee> NameComparator = new Comparator<Employee>() { // anonymous class
        @Override
        public int compare(Employee e1, Employee e2) { 
            return e1.getName().compareTo(e2.getName());
        }
    }
}
in calling class =>  Arrays.sort(emparr, Employee.NameComparator);
// this will sort according to name.

 ----------------------------------------------------
Comparator Vs Comparable




 ----------------------------------------------------



 ----------------------------------------------------


 ----------------------------------------------------



 ----------------------------------------------------



 ----------------------------------------------------



































